;; Analyzed by ClojureScript 1.7.170
{:use-macros nil, :excludes #{}, :name loom.flow, :imports nil, :requires {gen loom.alg-generic, loom.alg-generic loom.alg-generic}, :uses {bf-path loom.alg-generic}, :defs {residual-capacity {:protocol-inline nil, :meta {:file "/Users/onto/projects/Dynomics/public/js/loom/flow.cljc", :line 7, :column 7, :end-line 7, :end-column 24, :arglists (quote ([capacity flow v1 v2])), :doc "Computes the residual capacity between nodes v1 and v2. Capacity\n   is a function that takes two nodes, and returns the capacity on the\n   edge between them, if any. Flow is the adjacency map which\n   represents the current flow in the network."}, :name loom.flow/residual-capacity, :variadic false, :file "public/js/loom/flow.cljc", :end-column 24, :method-params ([capacity flow v1 v2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7, :end-line 7, :max-fixed-arity 4, :fn-var true, :arglists (quote ([capacity flow v1 v2])), :doc "Computes the residual capacity between nodes v1 and v2. Capacity\n   is a function that takes two nodes, and returns the capacity on the\n   edge between them, if any. Flow is the adjacency map which\n   represents the current flow in the network."}, flow-balance {:protocol-inline nil, :meta {:file "/Users/onto/projects/Dynomics/public/js/loom/flow.cljc", :line 18, :column 7, :end-line 18, :end-column 19, :arglists (quote ([flow])), :doc "Given a flow, returns a map of {node (sum(in weight) - sum(out weight))}"}, :name loom.flow/flow-balance, :variadic false, :file "public/js/loom/flow.cljc", :end-column 19, :method-params ([flow]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 18, :end-line 18, :max-fixed-arity 1, :fn-var true, :arglists (quote ([flow])), :doc "Given a flow, returns a map of {node (sum(in weight) - sum(out weight))}"}, satisfies-mass-balance? {:protocol-inline nil, :meta {:file "/Users/onto/projects/Dynomics/public/js/loom/flow.cljc", :line 28, :column 7, :end-line 28, :end-column 30, :arglists (quote ([flow source sink])), :doc "Given a flow, verifies whether at each node the sum of in edge\n   weights is equal to the sum of out edge weights, except at the\n   source and sink. The source should have positive net outflow, the\n   sink negative, and together they should balance."}, :name loom.flow/satisfies-mass-balance?, :variadic false, :file "public/js/loom/flow.cljc", :end-column 30, :method-params ([flow source sink]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 28, :end-line 28, :max-fixed-arity 3, :fn-var true, :arglists (quote ([flow source sink])), :doc "Given a flow, verifies whether at each node the sum of in edge\n   weights is equal to the sum of out edge weights, except at the\n   source and sink. The source should have positive net outflow, the\n   sink negative, and together they should balance."}, satisfies-capacity-constraints? {:protocol-inline nil, :meta {:file "/Users/onto/projects/Dynomics/public/js/loom/flow.cljc", :line 40, :column 7, :end-line 40, :end-column 38, :arglists (quote ([flow capacity])), :doc "Given a flow map, and a capacity function, verifies that the flow\n   on each edge is <= capacity of that edge."}, :name loom.flow/satisfies-capacity-constraints?, :variadic false, :file "public/js/loom/flow.cljc", :end-column 38, :method-params ([flow capacity]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 40, :end-line 40, :max-fixed-arity 2, :fn-var true, :arglists (quote ([flow capacity])), :doc "Given a flow map, and a capacity function, verifies that the flow\n   on each edge is <= capacity of that edge."}, is-admissible-flow? {:protocol-inline nil, :meta {:file "/Users/onto/projects/Dynomics/public/js/loom/flow.cljc", :line 51, :column 7, :end-line 51, :end-column 26, :arglists (quote ([flow capacity source sink])), :doc "Verifies that a flow satisfies capacity and mass balance\n   constraints. Does verify that a flow is maximum."}, :name loom.flow/is-admissible-flow?, :variadic false, :file "public/js/loom/flow.cljc", :end-column 26, :method-params ([flow capacity source sink]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 51, :end-line 51, :max-fixed-arity 4, :fn-var true, :arglists (quote ([flow capacity source sink])), :doc "Verifies that a flow satisfies capacity and mass balance\n   constraints. Does verify that a flow is maximum."}, min-weight-along-path {:protocol-inline nil, :meta {:file "/Users/onto/projects/Dynomics/public/js/loom/flow.cljc", :line 58, :column 7, :end-line 58, :end-column 28, :arglists (quote ([path weight-fn])), :doc "Given a path, represented by a sequence of nodes, and\n   weight-function, computes the minimum of the edge weights along the\n   path. If an edge on the path is missing, returns 0."}, :name loom.flow/min-weight-along-path, :variadic false, :file "public/js/loom/flow.cljc", :end-column 28, :method-params ([path weight-fn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 58, :end-line 58, :max-fixed-arity 2, :fn-var true, :arglists (quote ([path weight-fn])), :doc "Given a path, represented by a sequence of nodes, and\n   weight-function, computes the minimum of the edge weights along the\n   path. If an edge on the path is missing, returns 0."}, bf-find-augmenting-path {:protocol-inline nil, :meta {:file "/Users/onto/projects/Dynomics/public/js/loom/flow.cljc", :line 65, :column 7, :end-line 65, :end-column 30, :arglists (quote ([successors predecessors capacity flow s t])), :doc "Finds a shortest path in the flow network along which there remains\n   residual capacity. Successors is a function which, given a vertex,\n   returns the vertices connected by outgoing edges. Predecessors,\n   similarly is a function to get vertices connected by incoming\n   edges. Capacity is a function which takes two vertices and returns\n   the capacity between them. Flow is an adjacency map which contains\n   the current value of network flow. s is the source node, t the\n   sink."}, :name loom.flow/bf-find-augmenting-path, :variadic false, :file "public/js/loom/flow.cljc", :end-column 30, :method-params ([successors predecessors capacity flow s t]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 65, :end-line 65, :max-fixed-arity 6, :fn-var true, :arglists (quote ([successors predecessors capacity flow s t])), :doc "Finds a shortest path in the flow network along which there remains\n   residual capacity. Successors is a function which, given a vertex,\n   returns the vertices connected by outgoing edges. Predecessors,\n   similarly is a function to get vertices connected by incoming\n   edges. Capacity is a function which takes two vertices and returns\n   the capacity between them. Flow is an adjacency map which contains\n   the current value of network flow. s is the source node, t the\n   sink."}, augment-along-path {:protocol-inline nil, :meta {:file "/Users/onto/projects/Dynomics/public/js/loom/flow.cljc", :line 81, :column 7, :end-line 81, :end-column 25, :arglists (quote ([flow capacity path increase])), :doc "Given a flow represented as an adjacency map, returns an updated flow.\n   Capacity is a function of two vertices, path is a sequence of\n   nodes, and increase is the amount by which the flow should be\n   augmented on this path. If at any point the increase exceeds forward\n   capacity, the excess is pushed in the reverse direction. An exception\n   is thrown if the augmentation is impossible given capacity constraints."}, :name loom.flow/augment-along-path, :variadic false, :file "public/js/loom/flow.cljc", :end-column 25, :method-params ([flow capacity path increase]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 81, :end-line 81, :max-fixed-arity 4, :fn-var true, :arglists (quote ([flow capacity path increase])), :doc "Given a flow represented as an adjacency map, returns an updated flow.\n   Capacity is a function of two vertices, path is a sequence of\n   nodes, and increase is the amount by which the flow should be\n   augmented on this path. If at any point the increase exceeds forward\n   capacity, the excess is pushed in the reverse direction. An exception\n   is thrown if the augmentation is impossible given capacity constraints."}, edmonds-karp {:protocol-inline nil, :meta {:file "/Users/onto/projects/Dynomics/public/js/loom/flow.cljc", :line 110, :column 7, :end-line 110, :end-column 19, :arglists (quote ([successors predecessors capacity source sink] [successors predecessors capacity source sink flow])), :doc "Computes the maximum flow on a network, using the edmonds-karp algorithm.\n   Successors is a function that returns the outgoing neighbor\n   vertices of a vertex. Predecessors is a function that returns the\n   incoming neighbor vertices for a vertex. Capacity is a function of\n   two vertices that returns the capacity on the edge between them.\n   Source and sink are the unique vertices which supply and consume\n   flow respectively.\n\n   Returns a vector [flow value], where flow is an adjacency map that\n   represents flows between vertices, and value is the quantity of\n   flow passing from source to sink.", :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([successors predecessors capacity source sink] [successors predecessors capacity source sink flow]), :arglists ([successors predecessors capacity source sink] [successors predecessors capacity source sink flow]), :arglists-meta (nil nil)}}, :name loom.flow/edmonds-karp, :variadic false, :file "public/js/loom/flow.cljc", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([successors predecessors capacity source sink] [successors predecessors capacity source sink flow]), :arglists ([successors predecessors capacity source sink] [successors predecessors capacity source sink flow]), :arglists-meta (nil nil)}, :method-params ([successors predecessors capacity source sink] [successors predecessors capacity source sink flow]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 110, :end-line 110, :max-fixed-arity 6, :fn-var true, :arglists ([successors predecessors capacity source sink] [successors predecessors capacity source sink flow]), :doc "Computes the maximum flow on a network, using the edmonds-karp algorithm.\n   Successors is a function that returns the outgoing neighbor\n   vertices of a vertex. Predecessors is a function that returns the\n   incoming neighbor vertices for a vertex. Capacity is a function of\n   two vertices that returns the capacity on the edge between them.\n   Source and sink are the unique vertices which supply and consume\n   flow respectively.\n\n   Returns a vector [flow value], where flow is an adjacency map that\n   represents flows between vertices, and value is the quantity of\n   flow passing from source to sink."}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:else}, :order [:else]}, :doc "Algorithms for solving network flow"}